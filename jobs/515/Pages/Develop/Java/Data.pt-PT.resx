<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Serviços de Dados</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Noções Básicas</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Orientações:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Gestão de Dados e Análise de Negócio</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Conheça as tecnologias presentes no Azure que o ajudam a trabalhar com dados relacionais e não relacionais.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Orientações:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Gestão de dados: Escolher a Tecnologia Correta</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Familiarize-se com os diferentes cenários para as tecnologias de gestão de dados existentes no Azure.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Armazenamento do Azure</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Guia de funcionalidades:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Serviço Blob</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>Os blobs são o modo mais simples de armazenar grandes volumes de dados de texto ou dados binários não estruturados como, por exemplo, vídeo, áudio e imagens. Os blobs são um serviço gerido certificado de acordo com a norma ISO 27001 que pode ser dimensionado automaticamente de modo a armazenar até 100 terabytes de dados. Podem ser acedidos a partir de praticamente qualquer lugar via REST e APIs de cliente.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Guia de funcionalidades:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Serviço Tabela</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>As tabelas disponibilizam funções NoSQL para aplicações que necessitam de armazenar grandes volumes de dados não estruturados. As tabelas são um serviço gerido certificado de acordo com a norma ISO 27001 que pode ser dimensionado automaticamente de modo a armazenar até 100 terabytes de dados. Podem ser acedidas a partir de praticamente qualquer lugar via REST e APIs geridas.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Criar um mercado de imagens que utilize armazenamento de Blobs</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Crie uma aplicação que armazene imagens no armazenamento de blobs do Azure. Irá aprender a utilizar as Bibliotecas do Cliente Azure para Java e a forma de trabalhar com o armazenamento do Azure.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Como:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Utilizar um domínio personalizado com armazenamento do Blob</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Configure a sua conta de armazenamento de modo a mapear o seu domínio personalizado para o ponto final do serviço Blob, para que os utilizadores vejam o nome de domínio nos URLs da sua aplicação.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>Dados Relacionais</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Guia de funcionalidades:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>Base de Dados SQL</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Para as aplicações que necessitem de uma base de dados relacional com funcionalidades completas como um serviço, o Azure disponibiliza a Base de Dados SQL, anteriormente conhecida como Base de Dados SQL Azure. A Base de Dados SQL oferece uma interoperabilidade de elevado nível, com base na qual os clientes podem criar aplicações utilizando muitas das principais estruturas de desenvolvimento.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Como:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>Gerir a Base de Dados SQL do Azure com o SQL Server Management Studio</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>Pode utilizar o SQL Server Management Studio para gerir as bases de dados e os servidores lógicos da Base de Dados SQL. Este artigo inclui detalhes sobre a criação e gestão de bases de dados, a criação e gestão de inícios de sessão e a monitorização através das Vistas de Gestão Dinâmica.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Migrar uma Aplicação Java Spring Framework para o Azure e para a Base de Dados SQL do Azure</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Este tutorial ponto a ponto demonstra como migrar uma aplicação Spring Framework completa (a Java Pet Clinic) para o Azure, incluindo a utilização da Base de Dados SQL do Azure com JPA/Hibernate utilizando os mais recentes controladores JDBC do SQL Server.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>Crie uma aplicação web em Java com o DocumentDB</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>Este tutorial mostra-lhe como utilizar o serviço Azure DocumentDB para armazenar e aceder a dados a partir de uma aplicação Java alojada em Web sites do Azure.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>Dados não relacionais</value>
  </data>
</root>