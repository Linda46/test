<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Data Services</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Concetti fondamentali</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Guida:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Gestione dati e analisi aziendale</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Informazioni sulle tecnologie di Azure che consentono l&apos;uso di dati relazionali e non relazionali.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Guida:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Gestione dei dati: scegliere la tecnologia più adatta</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Informazioni sui diversi scenari per le tecnologie di gestione dati in Azure.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Archiviazione di Azure</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Guida alla funzionalità:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Servizio BLOB</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>I BLOB costituiscono il modo più semplice di archiviare grandi quantità di dati binari o testo non strutturato quali video, audio e immagini. I BLOB sono un servizio gestito certificato ISO 27001 che garantisce scalabilità automatica per supportare fino a 100 terabyte di dati. Sono accessibili praticamente ovunque tramite API REST e client.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Guida alla funzionalità:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Servizio tabella</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>Le tabelle offrono funzionalità NoSQL per applicazioni che richiedono l&apos;archiviazione di grandi quantità di dati non strutturati. Le tabelle sono un servizio gestito certificato ISO 27001 che garantisce scalabilità automatica per supportare fino a 100 terabyte di dati. Sono accessibili praticamente ovunque tramite API REST e gestite.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Esercitazione:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Creare un marketplace di immagini che usa l&apos;archiviazione BLOB</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Creare un&apos;applicazione che archivia immagini nell&apos;archiviazione BLOB di Azure. Si apprenderà come utilizzare le librerie client di Azure per Java e come lavorare con l&apos;archiviazione Azure.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Procedura:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Usare un dominio personalizzato con archiviazione BLOB</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Configurare l&apos;account di archiviazione per mappare il dominio personalizzato all&apos;endpoint del servizio BLOB, in modo che gli utenti visualizzino il proprio nome di dominio negli URL dell&apos;applicazione.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>Dati relazionali</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Guida alla funzionalità:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>Database SQL</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Per le applicazioni che richiedono un database relazionale completo come servizio, Azure offre Database SQL, in precedenza noto come Database SQL di Azure. Database SQL garantisce un elevato livello di interoperabilità, consentendo ai clienti di compilare applicazioni usando molti dei principali framework di sviluppo.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Procedura:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>Gestire Database SQL di Azure usando SQL Server Management Studio</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>È possibile usare SQL Server Management Studio per gestire server e database logici di Database SQL. Questo articolo include i dettagli sulla creazione e la gestione di database, la creazione e la gestione di login e il monitoraggio usando viste a gestione dinamica.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Esercitazione:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Eseguire la migrazione di un&apos;applicazione Java Spring Framework ad Azure e Database SQL di Azure</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Questa esercitazione end-to-end dimostra come eseguire la migrazione di un&apos;applicazione Spring Framework completa (Java Pet Clinic) ad Azure oltre all&apos;uso di Database SQL di Azure con JPA/Hibernate usando i driver JDBC di SQL Server più recenti.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Esercitazione:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>Creare un&apos;applicazione Web Java con DocumentDB</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>Questa esercitazione mostra come usare il servizio Azure DocumentDB per archiviare i dati e accedervi da un&apos;applicazione Java ospitata in Siti Web di Azure.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>Dati non relazionali</value>
  </data>
</root>