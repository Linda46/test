<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Veri Hizmetleri</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Temel Konular</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Kılavuz:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Veri Yönetimi ve İş Analizi</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Azure&apos;da hem ilişkisel hem de ilişkisel olmayan verilerle çalışmanıza yardımcı olan teknolojileri öğrenin.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Kılavuz:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Veri Yönetimi: Doğru Teknolojiyi Seçme</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Azure&apos;daki veri yönetim teknolojileriyle ilgili farklı senaryolar hakkında bilgi edinin.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Azure Depolama</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Özellik kılavuzu:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Blob Hizmeti</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>Blob&apos;lar büyük miktarda yapılandırılmamış metin ve video, ses ve görüntü gibi ikili verileri depolamanın en kolay yoludur. Blob&apos;lar 100 terabayta varan miktarda veriyi depolamak için otomatik olarak ölçeklenebilen, ISO 27001 sertifikalı bir yönetilen hizmettir. Bunlara REST ve istemci API&apos;leri yoluyla, neredeyse her yerden erişilebilir.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Özellik kılavuzu:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Tablo Hizmeti</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>Tablolar, büyük miktarda yapılandırılmamış veri depolaması gerektiren uygulamalar için NoSQL özellikleri sağlar. Tablolar 100 terabayta varan miktarda veriyi depolamak için otomatik olarak ölçeklenebilen, ISO 27001 sertifikalı bir yönetilen hizmettir. Bunlara REST ve yönetilen API&apos;ler yoluyla, neredeyse her yerden erişilebilir.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Öğretici:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Blob depolamasını kullanan bir görüntü marketi oluşturma</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Azure blob depolamasında görüntüleri depolayan bir uygulama oluşturur. Java için Azure İstemci Kitaplıkları&apos;nı kullanmayı ve Azure depolamasıyla çalışmayı öğreneceksiniz.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Nasıl yapılır:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Blob depolamasıyla özel bir etki alanı kullanma</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Kullanıcıların uygulamanızın URL&apos;lerinde etki alanı adınızı görebilmesi için, depolama hesabınızı özel etki alanınızı Blob hizmeti uç noktanızla eşleyecek şekilde yapılandırın.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>İlişkisel Veriler</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Özellik kılavuzu:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>SQL Veritabanı</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Azure, tam özellikli bir hizmet olarak ilişkisel veritabanına gerek duyan uygulamalar için SQL Veritabanı&apos;nı (eski adı SQL Azure Veritabanı) sunar. SQL Veritabanı yüksek düzeyde birlikte çalışabilirlik sağlayarak, müşterilerin birçok önemli geliştirme çerçevesini kullanarak uygulamalar oluşturmalarına olanak tanır.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Nasıl yapılır:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>SQL Server Management Studio&apos;yu kullanarak Azure SQL Veritabanı&apos;nı yönetme</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>SQL Veritabanı mantıksal sunucuları ve veritabanlarını yönetmek için SQL Server Management Studio&apos;yu kullanabilirsiniz. Bu makale, veritabanlarını oluşturma ve yönetme, oturum açma işlemlerini oluşturma ve yönetme, ayrıca Dinamik Yönetim Görünümleri&apos;nin kullanımını izleme hakkındaki ayrıntıları içerir.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Öğretici:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Bir Java Spring Çerçeve Uygulamasını Azure&apos;a ve Azure SQL Veritabanına Taşıma</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Bu uçtan uca öğretici Azure SQL Veritabanı&apos;nın en son SQL Server JDBC sürücülerini kullanan JPA/Hazırda Bekletme ile birlikte kullanılması dahil olmak üzere tam bir Spring Çerçeve uygulamasını (Java Pet Clinic) Azure&apos;a nasıl taşıyacağınızı gösterir.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Öğretici:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>DocumentDB kullanarak bir Java web uygulaması oluşturun</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>Bu öğreticide, Azure Web Sitelerinde barındırılan bir Java uygulamasındaki verileri depolamak ve erişmek amacıyla Azure DocumentDB hizmetinin nasıl kullanılacağı gösterilmektedir.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>İlişkisel Olmayan Veriler</value>
  </data>
</root>