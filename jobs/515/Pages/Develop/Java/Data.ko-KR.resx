<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>데이터 서비스</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>기본 사항</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> 지침:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>데이터 관리 및 비즈니스 분석</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Azure에서 관계형 및 비관계형 데이터 모두로 작업하는 데 도움이 되는 기술에 대해 알아봅니다.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> 지침:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>데이터 관리: 적절한 기술 선택</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Azure의 데이터 관리 기술에 대한 여러 시나리오를 알아봅니다.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Azure 저장소</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> 기능 가이드:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Blob 서비스</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>BLOB은 동영상, 오디오, 이미지와 같이 많은 양의 이진 데이터 또는 구조화되지 않은 텍스트를 간단하게 저장할 수 있는 방법을 제공합니다. Blob은 최대 100TB의 데이터를 저장하도록 크기를 자동으로 조정할 수 있는 ISO 27001 인증 관리 서비스입니다. REST 및 클라이언트 API를 통해 거의 어디에서나 액세스할 수 있습니다.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> 기능 가이드:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>테이블 서비스</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>테이블은 대량의 비구조적 데이터를 저장할 필요가 있는 응용 프로그램을 위해 NoSQL 기능을 제공합니다. 테이블은 최대 100TB의 데이터를 저장하도록 크기를 자동으로 조정할 수 있는 ISO 27001 인증 관리 서비스입니다. 테이블은 REST 및 관리되는 API를 통해 거의 어디에서나 액세스할 수 있습니다.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> 자습서:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Blob 저장소를 사용하는 이미지 마켓플레이스 만들기</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Azure blob 저장소에 이미지를 저장하는 응용 프로그램을 만듭니다. Java용 Azure 클라이언트 라이브러리를 사용하는 방법과 Azure 저장소로 작업하는 방법을 알아보세요.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> 방법:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Blob 저장소로 사용자 지정 도메인 사용</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>사용자 지정 도메인을 Blob 서비스 끝점으로 매핑하도록 저장소 계정을 구성하면 응용 프로그램 URL에 도메인 이름이 표시됩니다.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>관계형 데이터</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> 기능 가이드:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>SQL 데이터베이스</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>완전한 기능을 갖춘 관계형 데이터베이스를 서비스로 사용할 필요가 있는 응용 프로그램을 위해 Azure에서는 SQL 데이터베이스(이전의 SQL Azure 데이터베이스)를 제공합니다. SQL 데이터베이스는 높은 수준의 상호 운용성을 제공하므로 고객이 여러 주요 개발 프레임워크를 사용하여 응용 프로그램을 만들 수 있습니다.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> 방법:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>SQL Server Management Studio를 사용한 SQL 데이터베이스 관리</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>SQL Server Management Studio를 사용하여 SQL 데이터베이스 논리 서버 및 데이터베이스를 관리할 수 있습니다. 이 문서에는 데이터베이스 만들기 및 관리, 로그인 만들기 및 관리, 동적 관리 뷰를 이용한 모니터링에 대한 자세한 내용이 포함됩니다.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> 자습서:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Azure 및 Azure SQL 데이터베이스로 Java Spring Framework 응용 프로그램 마이그레이션</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>이 종단 간 자습서에서는 최신 SQL Server JDBC 드라이버를 사용하여 JPA/Hibernate와 함께 Azure SQL 데이터베이스를 사용하는 방법을 포함하여 전체 Spring Framework 응용 프로그램(Java Pet Clinic)을 Azure로 마이그레이션하는 방법을 보여 줍니다.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> 자습서:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>DocumentDB를 사용하여 Java 웹 응용 프로그램 작성</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>이 자습서에서는 Azure DocumentDB 서비스를 사용하여 Azure 웹 사이트에 호스트된 Java 응용 프로그램의 데이터에 액세스하고 데이터를 저장하는 방법을 보여 줍니다.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>비관계형 데이터</value>
  </data>
</root>