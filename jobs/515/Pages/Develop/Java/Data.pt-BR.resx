<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Serviços de Dados</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Princípios fundamentais</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Diretrizes:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Gerenciamento de Dados e Análise do Negócio</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Saiba mais sobre as tecnologias no Azure que o ajudam a trabalhar com dados relacionais e não relacionais.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Diretrizes:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Gerenciamento de dados: escolhendo a tecnologia certa</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Saiba sobre os diferentes cenários para tecnologias de gerenciamento de dados no Azure.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Armazenamento do Azure</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Guia do recurso:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Serviço de Blob</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>Os blobs são a maneira mais simples de armazenar grandes volumes de texto não estruturado ou dados binários, como vídeo, áudio e imagens. Os Blobs são um serviço gerenciado com certificação ISO 27001 com dimensionamento automático para armazenar até 100 terabytes de dados. Eles podem ser acessados de praticamente qualquer lugar via REST e APIs de cliente.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Guia do recurso:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Serviço de Tabelas</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>As tabelas não oferecem recursos de SQL para aplicativos que precisam armazenar grandes volumes de dados não estruturados. As tabelas são um serviço gerenciado com certificação ISO 27001 com dimensionamento automático para armazenar até 100 terabytes de dados. Eles podem ser acessados de praticamente qualquer lugar via REST e APIs gerenciadas.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Crie um marketplace de imagens que usa armazenamento em Blob</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Crie um aplicativo que armazena as imagens no armazenamento em blob do Azure. Você aprenderá como usar as bibliotecas do Cliente Azure para Java e como trabalhar com armazenamento do Azure.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Como:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Use um domínio personalizado com o armazenamento do Blob</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Configure a sua conta de armazenamento para mapear o seu domínio personalizado para o ponto de extremidade do seu serviço de Blob, para que os usuários vejam o nome do seu domínio nas URLs do seu aplicativo.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>Dados Relacionais</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Guia do recurso:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>Banco de dados SQL</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Para aplicativos que necessitam de um banco de dados relacional como um serviço cheio de recursos, o Azure oferece o banco de dados SQL, anteriormente conhecido como Banco de Dados do SQL Azure. O banco de dados SQL oferece alto nível de interoperabilidade, permitindo que os clientes compilem aplicativos que utilizam muitas das principais estruturas de desenvolvimento.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Como:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>Gerenciar o Banco de Dados SQL do Azure usando o SQL Server Management Studio</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>Você pode usar o SQL Server Management Studio para gerenciar servidores e bancos de dados lógicos do banco de dados SQL. Este artigo inclui detalhes sobre como criar e gerenciar bancos de dados, criar e gerenciar logins e monitorar usando exibições de gerenciamento dinâmico.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Migrar um aplicativo Java de estrutura Spring para Azure e Banco de Dados SQL do Azure</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Este tutorial completo demonstra como migrar todo um aplicativo de estrutura Spring (o Java Pet Clinic) para o Azure, incluindo o uso de banco de dados SQL do Azure com JPA/Hibernar usando os drivers JDBC mais recentes do SQL Server.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>Compilar um aplicativo Web Java usando o Banco de Dados de Documentos</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>Este tutorial mostra como usar o serviço Banco de Dados de Documentos do Azure para armazenar e acessar dados por meio de um aplicativo Java hospedado em Sites do Azure.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>Dados Não Relacionais</value>
  </data>
</root>