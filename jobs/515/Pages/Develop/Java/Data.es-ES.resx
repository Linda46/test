<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Servicios de datos</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Aspectos básicos</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Guía:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Administración de datos y análisis de negocios</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Información acerca de las tecnologías de Azure que le ayudarán a trabajar con datos relacionales y no relacionales.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Guía:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Administración de datos: elección de la tecnología adecuada</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Conozca los distintos escenarios para las tecnologías de administración de datos en Azure.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Almacenamiento de Azure</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Guía de características:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Servicio BLOB</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>Los blobs son el modo más sencillo de almacenar grandes cantidades de texto no estructurado o datos binarios tales como vídeo, audio e imágenes. Los blobs son un servicio administrado con certificación ISO 27001 que se puede escalar automáticamente para almacenar hasta 100 terabytes de datos. Son accesibles prácticamente desde cualquier lugar a través de las API REST y de cliente.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Guía de características:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Servicio Tabla</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>Las tablas ofrecen funcionalidad NoSQL para las aplicaciones que requieren el almacenamiento de grandes cantidades de datos no estructurados. Las tablas son un servicio administrado con certificación ISO 27001 que se puede escalar automáticamente para almacenar hasta 100 terabytes de datos. Son accesibles prácticamente desde cualquier lugar a través de las API REST y administradas.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Cree un catálogo de imágenes que use el almacenamiento de blobs</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Cree una aplicación que almacene imágenes en el almacenamiento de blobs de Azure. Aprenderá cómo usar las bibliotecas de cliente de Azure en Java y cómo trabajar con el almacenamiento de Azure.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Procedimientos:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Usar un dominio personalizado con el almacenamiento de blobs</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Configure la cuenta de almacenamiento para asignar el dominio personalizado al extremo de servicio BLOB, para que los usuarios puedan ver el nombre de dominio en las direcciones URL de su aplicación.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>Base de datos relacional</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Guía de características:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>Base de datos SQL</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Para las aplicaciones que necesitan una base de datos relacional completa como servicio, Azure ofrece la Base de datos SQL, conocida anteriormente como Base de datos SQL de Azure. La Base de datos SQL ofrece un elevado nivel de interoperabilidad, lo que permite a los cliente crear aplicaciones usando muchos de los principales marcos de desarrollo.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Procedimientos:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>Administrar Base de datos SQL de Azure mediante SQL Server Management Studio</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>Puede usar SQL Server Management Studio para administrar los servidores lógicos y las bases de datos de Base de datos SQL. Este artículo incluye detalles sobre la creación y la administración de bases de datos, la creación y administración de inicios de sesión y la supervisión mediante las vistas de administración dinámica.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Migrar una aplicación Spring Framework de Java a Azure y Base de datos SQL de Azure</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Este completo tutorial muestra cómo migrar una aplicación Spring Framework completa (Java Pet Clinic) a Azure, incluido el uso de Base de datos SQL de Azure con JPA/Hibernate mediante los controladores de SQL Server JDBC más recientes.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Tutorial:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>Crear una aplicación web Java usando Base de datos de documentos</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>Este tutorial muestra cómo usar el servicio Base de datos de documentos de Azure para almacenar y acceder a datos desde una aplicación Java hospedada en sitios web de Azure.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>Datos no relacionales</value>
  </data>
</root>