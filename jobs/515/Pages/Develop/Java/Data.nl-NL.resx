<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Gegevensservices</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Basisprincipes</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Hulp:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Gegevensbeheer en zakelijke analyse</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Ontdek meer over de technologieën in Azure waarmee u met zowel relationele als niet-relationele gegevens kunt werken.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Hulp:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Gegevensbeheer: de juiste technologie kiezen</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Ontdek de verschillende scenario&apos;s voor gegevensbeheertechnologie in Azure.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Azure Storage</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Overzicht van de functies:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Blob-service</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>Blobopslag is de eenvoudigste manier voor het opslaan van grote hoeveelheden ongestructureerde tekst of binaire gegevens zoals video, audio en afbeeldingen. Blobopslag is een beheerde service met ISO 27001-certificering waarmee automatisch kan worden geschaald om maximaal 100 terabytes aan gegevens op te slaan. Blobs zijn bijna overal toegankelijk via REST-API&apos;s en client-API&apos;s.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Overzicht van de functies:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Tabelservice</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>Tabellen bieden NoSQL-mogelijkheden voor toepassingen waarvoor grote hoeveelheden ongestructureerde gegevens moeten worden opgeslagen. Tabellen is een beheerde service met ISO 27001-certificering waarmee automatisch kan worden geschaald om maximaal 100 terabytes aan gegevens op te slaan. De service is bijna overal toegankelijk via REST-API&apos;s en beheerde API&apos;s.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Zelfstudie:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Een marketplace met installatiekopieën maken die gebruikmaakt van blobopslag</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Maak een toepassing die afbeeldingen opslaat in Azure-blobopslag. U leert hoe u de Azure-clientbibliotheken voor Java gebruikt en hoe u met Azure Storage werkt.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Zo kunt u:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Een aangepast domein met blobopslag gebruiken</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Configureer uw opslagaccount zodanig dat uw aangepaste domein wordt toegewezen aan uw blob-service-eindpunt, zodat gebruikers uw domeinnaam zien in de URL&apos;s van uw toepassing.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>Relationele gegevens</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Overzicht van de functies:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>SQL-database</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Voor toepassingen waarvoor een relationele database-as-a-service met een volledige functionaliteit is vereist, biedt Azure SQL Database, voorheen SQL Azure Database. SQL Database beschikt over hoge niveaus voor interoperabiliteit, waardoor klanten toepassingen kunnen maken met veel van de grote ontwikkelingsframeworks.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Zo kunt u:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>Azure SQL Database beheren met SQL Server Management Studio</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>U kunt SQL Server Management Studio gebruiken om logische servers en databases van SQL Database te beheren. Dit artikel bevat informatie over het maken en beheren van databases, het maken en beheren van aanmeldingen en het controleren met dynamische beheerweergaven.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Zelfstudie:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Een Java Spring Framework-toepassing naar Azure en Azure SQL Database migreren</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Deze complete zelfstudie laat zien hoe een complete Spring Framework-toepassing (de Java Pet Clinic) wordt gemigreerd naar Azure, inclusief het gebruik van Azure SQL Database met JPA/Hibernate met de nieuwste SQL Server JDBC-stuurprogramma&apos;s.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Zelfstudie:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>Een Java-webtoepassing maken met DocumentDB</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>In deze zelfstudie wordt uitgelegd hoe u de DocumentDB-service kunt gebruiken om gegevens uit een Java-toepassing op te slaan en te gebruiken die wordt gehost op Azure Websites.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>Niet-relationele gegevens</value>
  </data>
</root>