<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Section1_Heading1" xml:space="preserve">
    <value>Data Services</value>
  </data>
  <data name="Section1_Heading2" xml:space="preserve">
    <value>Grundlagen</value>
  </data>
  <data name="Section1_Heading3_Text1" xml:space="preserve">
    <value> Leitfaden:</value>
  </data>
  <data name="Section1_Heading3_Text2" xml:space="preserve">
    <value>Datenmanagement und Business Analytics</value>
  </data>
  <data name="Section1_Text1" xml:space="preserve">
    <value>Erfahren Sie mehr über die Technologien in Azure, die Sie bei der Arbeit mit sowohl relationalen als auch nicht-relationalen Daten unterstützen.</value>
  </data>
  <data name="Section1_Heading4_Text1" xml:space="preserve">
    <value> Leitfaden:</value>
  </data>
  <data name="Section1_Heading4_Text2" xml:space="preserve">
    <value>Datenverwaltung: Auswählen der richtigen Technologie</value>
  </data>
  <data name="Section1_Text2" xml:space="preserve">
    <value>Erfahren Sie mehr über verschiedene Szenarien für Datenmanagementtechnologien in Azure.</value>
  </data>
  <data name="Section1_Heading5" xml:space="preserve">
    <value>Azure-Speicher</value>
  </data>
  <data name="Section1_Heading6_Text1" xml:space="preserve">
    <value> Featureleitfaden:</value>
  </data>
  <data name="Section1_Heading6_Text2" xml:space="preserve">
    <value>Blob-Dienst</value>
  </data>
  <data name="Section1_Text3" xml:space="preserve">
    <value>BLOBs sind die einfachste Methode zum Speichern von unstrukturierten Text- oder Binärdaten wie Videos, Audiodateien oder Bilder. Blobs sind ein ISO 27001-zertifizierter verwalteter Dienst, der automatisch für eine Datenspeicherung von bis zu 100 Terabyte skaliert werden kann. Auf BLOBs kann über REST und Client-APIs von nahezu überall aus zugegriffen werden.</value>
  </data>
  <data name="Section1_Heading7_Text1" xml:space="preserve">
    <value> Featureleitfaden:</value>
  </data>
  <data name="Section1_Heading7_Text2" xml:space="preserve">
    <value>Tabellendienst</value>
  </data>
  <data name="Section1_Text4" xml:space="preserve">
    <value>Tabellen bieten NoSQL-Funktionen für Anwendungen, für die große Mengen an unstrukturierten Daten gespeichert werden müssen. Tabellen sind ein ISO 27001-zertifizierter verwalteter Dienst, der automatisch für eine Datenspeicherung von bis zu 100 Terabyte skaliert werden kann. Auf Tabellen kann über REST und verwaltete APIs von nahezu überall aus zugegriffen werden.</value>
  </data>
  <data name="Section1_Heading8_Text1" xml:space="preserve">
    <value> Lernprogramm:</value>
  </data>
  <data name="Section1_Heading8_Text2" xml:space="preserve">
    <value>Erstellen eines Image-Marketplace, der den BLOB-Speicher verwendet</value>
  </data>
  <data name="Section1_Text5" xml:space="preserve">
    <value>Erstellen Sie eine Anwendung, die Images im Azure-BLOB-Speicher speichert. Sie erfahren, wie Sie die Azure-Clientbibliotheken für Java verwenden und Azure Storage nutzen.</value>
  </data>
  <data name="Section1_Heading9_Text1" xml:space="preserve">
    <value> Anleitung:</value>
  </data>
  <data name="Section1_Heading9_Text2" xml:space="preserve">
    <value>Verwenden einer benutzerdefinierten Domäne mit Blob-Speicher</value>
  </data>
  <data name="Section1_Text6" xml:space="preserve">
    <value>Konfigurieren Sie Ihr Speicherkonto so, dass Ihre benutzerdefinierte Domäne dem Blob-Dienstendpunkt zugeordnet ist, sodass Benutzern Ihr Domänennamen in der Anwendungs-URL angezeigt wird.</value>
  </data>
  <data name="Section1_Heading10" xml:space="preserve">
    <value>Relationale Daten</value>
  </data>
  <data name="Section1_Heading11_Text1" xml:space="preserve">
    <value> Featureleitfaden:</value>
  </data>
  <data name="Section1_Heading11_Text2" xml:space="preserve">
    <value>SQL-Datenbank</value>
  </data>
  <data name="Section1_Text7" xml:space="preserve">
    <value>Für Anwendungen, die eine relationale, als Dienst bereitgestellte Datenbank mit vollem Funktionsumfang erfordern, bietet Azure die SQL-Datenbank, ehemals SQL Azure-Datenbank. Die SQL-Datenbank bietet eine allgemeine Interoperabilität, die Kunden ermöglicht, Anwendungen mithilfe vieler der wichtigsten Entwicklungsframeworks zu erstellen.</value>
  </data>
  <data name="Section1_Heading12_Text1" xml:space="preserve">
    <value> Anleitung:</value>
  </data>
  <data name="Section1_Heading12_Text2" xml:space="preserve">
    <value>Verwalten von Azure SQL-Datenbank mithilfe von SQL Server Management Studio</value>
  </data>
  <data name="Section1_Text8" xml:space="preserve">
    <value>Sie können SQL Server Management Studio verwenden, um die logischen Server und Datenbanken der SQL-Datenbank zu verwalten. Dieser Artikel enthält Informationen über die Erstellung und Verwaltung von Datenbanken, die Erstellung und Verwaltung von Anmeldungen und die Überwachung mithilfe von dynamischen Verwaltungssichten.</value>
  </data>
  <data name="Section1_Heading13_Text1" xml:space="preserve">
    <value> Lernprogramm:</value>
  </data>
  <data name="Section1_Heading13_Text2" xml:space="preserve">
    <value>Migrieren einer Java Spring Framework-Anwendung zu Azure und zur Azure SQL-Datenbank</value>
  </data>
  <data name="Section1_Text9" xml:space="preserve">
    <value>Dieses End-to-End-Lernprogramm veranschaulicht die Migration einer vollständigen Spring Framework-Anwendung (die Java Pet Clinic) zu Azure. Dies umfasst auch die Verwendung der Azure SQL-Datenbank mit JPA/Hibernate mithilfe aktueller SQL Server-JDBC-Treiber.</value>
  </data>
  <data name="Section1_Heading14_Text1" xml:space="preserve">
    <value> Lernprogramm:</value>
  </data>
  <data name="Section1_Heading14_Text2" xml:space="preserve">
    <value>Erstellen einer Java-Webanwendung mit DocumentDB</value>
  </data>
  <data name="Section1_Text10" xml:space="preserve">
    <value>In diesem Lernprogramm erfahren Sie, wie Sie mit dem Azure DocumentDB-Dienst Daten aus einer in Azure Websites gehosteten Java-Anwendung speichern und auf diese zugreifen.</value>
  </data>
  <data name="Section1_Heading11" xml:space="preserve">
    <value>Nicht relationale Daten</value>
  </data>
</root>